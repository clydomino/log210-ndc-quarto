#  Principes GRASP

GRASP est un acronyme de l’expression anglaise « General Responsibility Assignment Software Patterns »
c’est-à-dire les principes pour affecter les responsabilités logicielles dans les classes.
Une approche GRASP devrait amener un design vers la modularité et la maintenabilité.
L’acronyme d’une expression vulgarisée pourrait être POMM: « Principes pour déterminer Où Mettre une
Méthode ».
En tant qu’ingénieur logiciel, vous devez décider souvent où placer une méthode (dans quelle classe) et cette
décision ne devrait pas être prise de manière arbitraire, mais plutôt en suivant les directives d’ingénierie
favorisant la modularité.
Alors, les GRASP sont les directives qui vous aident à prendre des décisions de conception, menant à un
design avec moins de couplage inutile et des classes plus cohésives. Les classes cohésives sont plus faciles à
comprendre, à maintenir et à réutiliser.

::: {.callout-important icon="false" appearance="simple"}

Avez-vous déjà une bonne expérience en programmation? Avez-vous l’habitude de coder rapidement des solutions qui fonctionnent? Si la réponse est oui, alors travailler avec les principes
GRASP peut être un défi pour vous. Dans LOG210, vous devez être en mesure de justifier vos choix
de conception et cela va vous ralentir au début. Le but avec les principes GRASP est de (ré)apprendre
à faire du code qui fonctionne, mais qui soit également facile à maintenir. C’est normal au début que
ça prenne plus de temps, car il faut réfléchir pour appliquer les principes. Une fois que vous avez
l’habitude à utiliser les GRASP, vous serez encore rapide avec votre développement, mais en plus
votre design sera meilleur sur le plan de la maintenabilité.

:::


## Spectre de la conception

Neal Ford (2009) a [proposé](https://www.ibm.com/developerworks/library/j-eaed1/index.html) la notion d’effort pour la conception qu’il a nommée le « Spectre de la conception ». La figure 6.1 illustre le principe.
À une extrémité, il y a la mentalité de mettre presque zéro effort pour une conception, que l’on nomme
« Hacking cowboy ». C’est le cas lors d’un hackathon (un marathon de programmation durant 24 ou 48
heures où il faut produire une solution rapidement). Vous ne feriez pas un logiciel avec 10 patrons GoF ou
les diagrammes UML pour réfléchir à votre architecture. Mais vous savez aussi que le code qui est produit
lors d’un hackathon ne sera pas facile à maintenir. Le seul but est de faire du code qui marche pour montrer
une idée intéressante.
Au fait, dans certains contextes d’entreprise (par exemple une entreprise en démarrage qui a seulement six
mois de financement), c’est une situation similaire. Si une solution de [« produit minimum viable » (MVP en
anglais)](https://en.wikipedia.org/wiki/Minimum_viable_product) n’existe pas à la fin de la période de financement, l’entreprise n’existera plus, car il n’y aura



pas une deuxième période de financement. Si la compagnie est financée pour une deuxième période, la
conception du code pourrait avoir besoin de beaucoup de soins, car elle a été négligée. Cette négligence à la
conception (pour la maintenabilité) est aussi nommée [la dette technique](#sec-DetteTechnique).
À l’autre extrémité du spectre, c’est beaucoup d’effort dépensé sur la conception, que l’on nomme « Cascade
pure ». Dans le cycle de vie en cascade, on met un temps fixe, par exemple plusieurs mois, à étudier la
conception. Comme toute chose poussée à l’extrême, ce n’est pas idéal non plus. Dans le livre du cours,
Larman explique en détail des problèmes posés par une approche en cascade. Dans certains domaines, par
exemple les logiciels pour le contrôle d’avion ou des appareils médicaux, une approche en cascade est
encore utilisée, en dépit des problèmes dus à l’approche. La sécurité et la robustesse des logiciels sont très
importantes, alors on passe beaucoup de temps à vérifier et valider la conception. Puisque les exigences
sont plus stables (et les développeurs ont *a priori* une meilleure compréhension du domaine), l’approche en
cascade n’est pas si mal. Pourtant le coût pour produire des logiciels certifiés est énorme.
Le spectre de la conception est très important pour LOG210, parce que votre bagage d’ingénieur devrait
vous permettre de travailler partout sur ce spectre. C’est le contexte de l’entreprise pour laquelle vous
travaillez qui déterminera combien d’effort à mettre sur la conception.

##  Tableau des principes GRASP

Voici un extrait du livre du cours, **UML 2 et les design patterns** de Craig Larman.

: Patterns (principes) GRASP. {#tbl-patterns}

Pattern | Description
:----------|:----------
Expert en\ information\ F16.11/A17.11 \faBook<i class="fa-solid fa-book"></i>| Un principe général de conception d’objets et d’affectation des responsabilités.\
Affecter une responsabilité à l’expert – la classe qui possède les informations nécessaires pour s’en acquitter.\newline


##   GRASP et RDCU

Les principes GRASP sont utilisés dans les réalisations de cas d’utilisation (RDCU). On s’en sert pour annoter
les décisions de conception, pour rendre explicites (documenter) les choix. Voir la section Réalisations de
cas d’utilisation (RDCU) pour plus d’informations.

##  GRASP et Patterns GoF

On peut voir les principes GRASP comme des généralisations (principes de base) des patterns GoF. Voir la
section Décortiquer les patterns GoF avec GRASP pour plus d’informations



{{< pagebreak >}}